<?php

/**
 * @file
 * Module file.
 */

use Drupal\Core\Cache\Cache;
use Drupal\Core\Form\FormStateInterface;
use Symfony\Component\Yaml\Yaml;

/**
 * Implements hook_form_alter().
 */
function migration_glue_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  // If migration mapper form.
  if ($form_id == 'migration_admin_form') {
    $form['output']['#tree'] = TRUE;

    // Get source type.
    $source_type = $form['source']['data_source']['#default_value'];

    // In case of JSON/XML source type.
    if ($source_type == 'json' || $source_type == 'xml') {
      $form['source']['data_source_config_wrapper']['source']['read_directory'] = [
        '#type' => 'checkbox',
        '#title' => t('Is directory?'),
        '#description' => t('If checked, then will iterate all JSON/XML files in the given directory.')
      ];
    }

    $default_option_label = $form['migration_group']['#options']['default'];
    $form['migration_group']['#options'] = ['default' => $default_option_label];

    // Using 'default' migration group for all.
    // @todo - Make it generic.
    $form['migration_group']['#default_value'] = 'default';

    // Adding a submit button.
    $form['next_step'] = [
      '#type' => 'submit',
      '#value' => t('Go to next step'),
      '#validate' => ['_migration_glue_validate_handler'],
      '#submit' => ['_migration_glue_submit_handler'],
    ];
  }
}

/**
 * Custom validation handler.
 */
function _migration_glue_validate_handler(array &$form, FormStateInterface $form_state) {
  // Source type.
  $source_type = $form_state->getValue('data_source');

  // If XML or JSON.
  if ($source_type == 'json' || $source_type == 'xml') {
    $source = $form_state->getValue('data_source_config_wrapper')['source'];
    // Directory path.
    $dir_path = $source[$source_type . '_path'];
    // If not a valid directory, throw error.
    if ($source['read_directory'] && !is_dir($dir_path)) {
      $form_state->setErrorByName('data_source_config_wrapper][source][' . $source_type . '_path', t('Please provide a valid directory.'));
    }
    elseif($source['read_directory']) {
      // @todo: Need to revisit this once
      // https://www.drupal.org/project/migrate_plus/issues/2921374 is fixed.
      // Get all files from the directory of given type.
      $files = _migration_glue_get_all_files_in_directory($dir_path, $source_type);

      // If no file found in the given directory of given type.
      if (empty($files)) {
        $form_state->setErrorByName('data_source_config_wrapper][source][' . $source_type . '_path', t('No file available of the @type type in the @directory directory.', [
          '@type' => $source_type,
          '@directory' => $dir_path,
        ]));
      }
      else {
        $form_state->setValue(['data_source_config_wrapper', 'source', $source_type . '_path'], $files);
      }
    }
  }
}

/**
 * Custom submit handler.
 */
function _migration_glue_submit_handler(array &$form, FormStateInterface $form_state) {
  // Get exported output.
  $output = $form_state->getValue('output')['export'];
  $source = $form_state->getValue('data_source_config_wrapper')['source'];
  $source_type = $form_state->getValue('data_source');
  // It will be like 'json_item_selector' or 'xml_item_selector'.
  $item_selector_key = $source_type . '_item_selector';
  // It will be like 'json_path' or 'xml_path'.
  $url_path = $source_type . '_path';

  // If source is JSON/XML.
  if ($source_type == 'json' || $source_type == 'xml') {
    // Item selector must have a trailing slash as we are replacing it with empty
    // string. If no tailing slash, then we adding it here.
    $item_selector = substr($source[$item_selector_key], -1) == '/' ? $source[$item_selector_key] : $source[$item_selector_key] . '/';

    // We are removing item selector from the source and process part of the
    // migration output otherwise migration throws error -
    // "Migration failed with source plugin exception: /pages/page/id is defined
    // as a source ID but has no value".
    $output = str_replace($item_selector, '', $output);

    // Parsed yml to array.
    $parsed_yml = Yaml::parse($output);

    $parsed_yml['source']['urls'] = $source[$url_path];
    $parsed_yml['source']['item_selector'] = $source[$item_selector_key];
  }
  else {
    // Parsed yml to array.
    $parsed_yml = Yaml::parse($output);
  }

  // Register the migration in system.
  _migration_glue_register_migration($parsed_yml);

  // Invalidate the cache so that the 'discovery_migration' cache bin re-built.
  Cache::invalidateTags(['migration_plugins']);

  // Adding status message.
  \Drupal::messenger()->addStatus(t('Migration @migration has been created successfully.', ['@migration' => $parsed_yml['id']]));

  // Redirect to next step.
  $form_state->setRedirect('migration_glue.run_migration', [
    'migration' => $parsed_yml['id'],
    'migration_group' => $parsed_yml['migration_group'],
  ]);
}

/**
 * Gets all files of given type from the given directory recursively.
 *
 * @param string $directory_path
 *   Directory path.
 * @param string $file_type
 *   File type (JSON/XML).
 *
 * @return array
 *   All files of given type in the given directory.
 */
function _migration_glue_get_all_files_in_directory(string $directory_path, string $file_type = 'json') {
  return glob($directory_path . '/*.' . $file_type);
}

/**
 * Register a migration to the system.
 *
 * @param array $yml_data
 *   YML content.
 */
function _migration_glue_register_migration(array $yml_data = []) {
  if (!empty($yml_data)) {
    $migration_name = 'migrate_plus.migration.' . $yml_data['id'];
    \Drupal::configFactory()->getEditable($migration_name)->setData($yml_data)->save();
  }
}
